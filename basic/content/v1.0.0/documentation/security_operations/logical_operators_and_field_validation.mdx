This documentation guide provides a comprehensive overview of logical operators and field validation techniques used within UTMStack for correlation rules and log analysis. It covers various operators for comparing field content, checking for existence, validating IP addresses against CIDR ranges, and performing numeric comparisons. Additionally, it offers insights into best practices for leveraging cache versus search in log analysis and demonstrates practical field validation through correlation rule examples and Log Explorer filter configurations.

---

## Logical Operators

Logical operators are fundamental for defining conditions and filtering data in correlation rules and log analysis. They enable precise validation of field content against specified values or patterns.

### Equality and Inequality Operators

These operators compare field content with a given value.

*   `**==**`
    *   **Description**: True if the field's content is exactly equal to the "value" content. It is sensitive to capital letters.
    *   **Example**:
        *   `hello == Hello` //False
        *   `hello == hello` //True

*   `**::**`
    *   **Description**: True if the field's content is equal to the "value" content, ignoring case sensitivity.
    *   **Example**:
        *   `hello :: Hello` //True
        *   `hello :: hello` //True

*   `**!=**` or `**<>**`
    *   **Description**: True if the field's content is unequal to the "value" content. It is sensitive to capital letters.
    *   **Example**:
        *   `hello != Hello` //True
        *   `hello != hello` //False

*   `**!!**`
    *   **Description**: True if the field's content is unequal to the "value" content, ignoring case sensitivity.
    *   **Example**:
        *   `hello !! Hello` //False
        *   `hello !! hello` //False

### Existence Operators

These operators check for the presence or absence of a field. The "value" must be left empty as it is not used in the comparison.

*   `**exist**`
    *   **Description**: True if the field exists.

*   `**not exist**`
    *   **Description**: True if the field does not exist.

### CIDR Range Operators

These operators validate if an IP address falls within a specified CIDR range.

*   `**in cidr**`
    *   **Description**: True if the IP in the field is within the value range.

*   `**not in cidr**`
    *   **Description**: True if the IP in the field is not within the value range.

### Containment Operators

These operators check if a string value is part of another string.

*   `**contains**`
    *   **Description**: True if the "value" content is part of the field content.
    *   **Example**:
        *   `“hello world” contains “world”` //True
        *   `“hello world” contains “worlds”` //False

*   `**not contain**`
    *   **Description**: True if the "value" content is not part of the field content.
    *   **Example**:
        *   `” hello world ” not contain ” world ”` //False
        *   `” hello world ” not contain ” worlds”` //True

### Numeric Comparison Operators

These operators apply only to numbers. Use them when both the field content and the "value" are numeric.

*   `<` (Less than)
*   `>` (Greater than)
*   `<=` (Less than or equal to)
*   `>=` (Greater than or equal to)

### Regular Expression Operators

These operators allow for pattern matching using regular expressions.

*   `**regexp**`
    *   **Description**: True if the "value" content matches the regular expression in the field content.
    *   **Example**:
        *   `” hello world ” regexp ”^[a-z]+\[[0-9]+\]$”` //False

*   `**not regexp**`
    *   **Description**: True if the "value" content does not match the regular expression in the field content.
    *   **Example**:
        *   `” hello world ” not regexp ”^[a-z]+\[[0-9]+\]$”` //True

## Field Referencing and Validation in Correlation Rules

Correlation rules utilize a structured approach for referencing fields and applying validation logic.

### Field Path Syntax

A field is typically a series of keys separated by dots. Special wildcard characters can be used:
*   `*`: Matches any sequence of characters.
*   `?`: Matches any single character.
*   `#`: Used to get the number of elements in a slice or to access a child path.
*   Indices (e.g., `children.1`): Access a specific value within a slice.
*   Escaping: Dot and wildcard characters can be escaped with `\`.

**Examples of Field Referencing:**
```
{
  "name": {"first": "Tom", "last": "Anderson"},
  "age":37,
  "children": ["Sara","Alex","Jack"],
  "fav.movie": "Deer Hunter",
  "friends": [
    {"first": "Dale", "last": "Murphy", "age": 44, "nets": ["ig", "fb", "tw"]},
    {"first": "Roger", "last": "Craig", "age": 68, "nets": ["fb", "tw"]},
    {"first": "Jane", "last": "Murphy", "age": 47, "nets": ["ig", "tw"]}
  ]
}

"name.last"                           >> "Anderson"
"age"                                 >> 37
"children"                            >> ["Sara","Alex","Jack"]
"children.#"                          >> 3
"children.1"                          >> "Alex"
"child*.2"                            >> "Jack"
"c?ildren.0"                          >> "Sara"
"fav\.movie"                          >> "Deer Hunter"
"friends.#.first"                     >> ["Dale","Roger","Jane"]
"friends.1.last"                      >> "Craig"
"friends.#(last=="Murphy").first"     >> "Dale"
"friends.#(last=="Murphy")#.first"    >> ["Dale","Jane"]
"friends.#(age>45)#.last"             >> ["Craig","Murphy"]
"friends.#(first%"D*").last"          >> "Murphy"
"friends.#(first!%"D*").last"         >> "Craig"
"friends.#(nets.#(=="fb"))#.first"    >> ["Dale","Roger"]
```

### Querying Slices

You can query a slice for the first match using `#(...)` or find all matches with `#(...)#`. These queries support comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`) and simple pattern matching operators (`%` and `!%`).

### Logical Grouping (`allOf` and `oneOf`)

Within correlation rules, `allOf` and `oneOf` define how multiple comparison conditions are combined:
*   `**cache -> allOf**` / `**search -> allOf**`
    *   All comparisons within this field must be met for the rule to generate an alert.
*   `**cache -> oneOf**` / `**search -> oneOf**`
    *   Any comparison within this field must be met for the rule to generate an alert.

## When to Use Cache or Search

The choice between `cache` and `search` in correlation rules depends on the analysis period and complexity.

*   **Cache**:
    *   **Recommendation**: Use for rules that analyze logs in a maximum of 1 hour.
    *   **Declaration**: The `cache` field declares that iterations will occur on the correlation engine's cache. When `cache` is used, the `search` field is not used.
    *   **`timeLapse`**: Specifies how much time backward in seconds will be checked in the logs.
    *   **`minCount`**: Defines the minimum number of logs that must be obtained as a result for the rule to be met.

*   **Search**:
    *   **Recommendation**: Use when the analysis period exceeds 1 hour or the rule's complexity is very high and cannot be handled by the cache.
    *   **Declaration**: The `search` field declares that iterations will occur on Elasticsearch/OpenSearch. When `search` is used, the `cache` field is not used.
    *   **`query`**: The Elasticsearch or OpenSearch query in JSON format, which must be enclosed in simple quotation marks.
    *   **`minCount`**: Defines the minimum number of logs that must be obtained as a result for the rule to be met.

## Saving Fields and Using Aliases

The `save` field is used to store required fields for subsequent iteration cycles or to complete alert information.

*   `**[cache | search] -> save -> field**`
    *   The original name of the field to store.
*   `**[cache | search] -> save -> alias**`
    *   The alias or name used to access the stored field. There cannot be two or more aliases with the same name within the same iteration.

In the last iteration of a rule, the system uses specific aliases to populate alert details:
*   Protocol
*   SourceUser
*   SourceHost
*   SourceIP
*   SourcePort
*   DestinationUser
*   DestinationHost
*   DestinationIP
*   DestinationPort

Geolocation information is automatically filled from the `SourceIP` and `DestinationIP` aliases. If `SourceIP` or `DestinationIP` do not exist, the system generates them using `SourceHost` and `DestinationHost`, and vice versa.
If `AlertName` and `AlertCategory` aliases are saved in the last iteration, the alert name or category will be overwritten with their content.

## Example: Windows Authentication Failure Correlation Rule

This example demonstrates field validation and logical operators in a correlation rule designed to detect repeated Windows authentication failures.

```yaml
- name: Windows authentication failure
  severity: Low
  description: A Windows user was unable to authenticate with the server or workstation more than 5 times.
  solution: Refer to NIST guidelines when creating password policies and set account lockout policies after a certain number of failed login attempts to prevent passwords from being guessed. Too strict a policy may create a denial of service condition and render environments un-usable, with all accounts used in the brute force being locked-out.
  category: User Account Authentication
  tactic: "Brute Force: Password Guessing"
  dataTypes: ["wineventlog"]
  reference:
    - "https://attack.mitre.org/techniques/T1110/001/"
  frequency: 10
  cache:
    - allOf:
        - field: logx.wineventlog.event_id
          operator: "=="
          value: 4625
      minCount: 1
      timeLapse: 15
      save:
        - field: logx.wineventlog.event_data.TargetUserName
          alias: DestinationUser
        - field: logx.wineventlog.host.name
          alias: DestinationHost
    - allOf:
        - field: logx.wineventlog.event_id
          operator: "=="
          value: 4625
        - field: logx.wineventlog.event_data.TargetUserName
          operator: "=="
          value: "{{.DestinationUser}}"
        - field: logx.wineventlog.host.name
          operator: "=="
          value: "{{.DestinationHost}}"
      minCount: 5
      timeLapse: 60
      save:
        - field: logx.wineventlog.event_data.TargetUserName
          alias: DestinationUser
        - field: logx.wineventlog.host.name
          alias: DestinationHost
        - field: logx.wineventlog.event_data.WorkstationName
          alias: SourceHost
        - field: logx.wineventlog.event_data.IpAddress
          alias: SourceIP
```

**Search-based Example:**
```yaml
- name: Windows authentication failure
  severity: Low
  description: A Windows user was unable to authenticate with the server or workstation more than 5 times.
  solution: Refer to NIST guidelines when creating password policies and set account lockout policies after a certain number of failed login attempts to prevent passwords from being guessed. Too strict a policy may create a denial of service condition and render environments un-usable, with all accounts used in the brute force being locked-out.
  category: User Account Authentication
  tactic: "Brute Force: Password Guessing"
  dataTypes: ["wineventlog"]
  reference:
    - "https://attack.mitre.org/techniques/T1110/001/"
  frequency: 10
  search:
    - query: '{"size": 500, "query": {"bool": {"must": [{"match_phrase": {"logx.wineventlog.event_id": 4625}}], "filter": [{"range": {"@timestamp": {"gte": "now-15s", "lte": "now"}}}], "should": [], "must_not": []}}}'
      minCount: 1
      save:
        - field: logx.wineventlog.event_data.TargetUserName
          alias: DestinationUser
        - field: logx.wineventlog.host.name
          alias: DestinationHost
    - query: '{"size": 500, "query": {"bool": {"must": [{"match_phrase": {"logx.wineventlog.event_id": 4625}}, {"match_phrase": {"logx.wineventlog.event_data.TargetUserName": "{{.DestinationUser}}"}}], "filter": [{"range": {"@timestamp": {"gte": "now-60s", "lte": "now"}}}], "should": [], "must_not": [{"match_phrase": {"logx.wineventlog.event_data.TargetUserName": "{{.DestinationHost}}$"}}]}}}'
      minCount: 5
      save:
        - field: logx.wineventlog.event_data.TargetUserName
          alias: DestinationUser
        - field: logx.wineventlog.host.name
          alias: DestinationHost
        - field: logx.wineventlog.event_data.WorkstationName
          alias: SourceHost
        - field: logx.wineventlog.event_data.IpAddress
          alias: SourceIP
```

## Field Validation in Log Explorer

The Log Explorer module provides a user-friendly interface to apply filters based on specific log fields and values, showcasing field validation in a practical context. Users can easily add filters to refine displayed log data.

### Example: Office 365 Login Failure Analysis

To filter for Office 365 login failure events:

1.  **Source Selection**: In the Source field, type and select `log-o365-*` from the dropdown list.
2.  **Filter Configuration**:
    *   Click on the ‘Add Filter’ button.
    *   In the Field dropdown, find and select `logx.o365.Operation.keyword`.
    *   In the Operator dropdown, select `is`.
    *   Type `UserLoginFailed` in the Value input box.
    *   Click **Add Filter** to apply this filter.

This process demonstrates how field validation, using an operator (`is`) and a specific value (`UserLoginFailed`), is applied to narrow down log data in the Log Explorer.

---

## Summary

This guide has detailed the various logical operators available in UTMStack for precise field validation, including equality, inequality, existence, CIDR range, containment, and numeric comparisons. It also covered the syntax for referencing fields with wildcards and slices, and how to combine conditions using `allOf` and `oneOf`. Best practices for choosing between `cache` and `search` for log analysis based on timeframes and complexity were outlined, alongside the mechanism for saving and aliasing fields. Practical examples, such as the Windows authentication failure correlation rule and filtering in Log Explorer for Office 365 login failures, illustrate the application of these concepts for effective security monitoring and log analysis.