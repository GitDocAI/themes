This documentation page provides a comprehensive guide on how UTMStack manages alert data population, including the use of aliases for detailed information, automatic geolocation, methods for iterating over data, and the various comparison operators available for defining correlation rules.

---

## Alert Details Population and Geolocation

UTMStack utilizes specific aliases to populate alert details in the final iteration of its correlation engine. These aliases ensure that critical information is consistently captured and presented in generated alerts.

### Aliases for Alert Details

In the last iteration of a rule, the system uses the following aliases to fill in the alert details:

*   `Protocol`
*   `SourceUser`
*   `SourceHost`
*   `SourceIP`
*   `SourcePort`
*   `DestinationUser`
*   `DestinationHost`
*   `DestinationIP`
*   `DestinationPort`

If any field is saved with the aliases `AlertName` and `AlertCategory` in the last iteration, the alert name or category will be overwritten with the content of those aliases, respectively.

### Automatic Geolocation

Geolocation information is automatically populated using the `SourceIP` and `DestinationIP` aliases. If either `SourceIP` or `DestinationIP` aliases do not exist, the system will generate them using `SourceHost` and `DestinationHost`, and vice versa.

---

## Iterating Over Data

Correlation rules can iterate over data stored in Elasticsearch/OpenSearch or within the correlation engine's cache. This allows for complex analysis and pattern detection.

### Search Iterations (Elasticsearch/OpenSearch)

The `search` field declares that iterations will occur on Elasticsearch or OpenSearch. It contains the definition of these iterations. When `search` is used, the `cache` field is not used, and vice versa.

*   **`search -> query`**: This field defines the Elasticsearch or OpenSearch query in JSON format. The query must be enclosed in simple quotation marks.

### Cache Iterations (Correlation Engine Cache)

The `cache` field declares that iterations will occur on the cache of the correlation engine. It contains the definition of said iterations. When `cache` is used, the `search` field is not used, and vice versa.

*   **`cache -> timeLapse`**: Specifies how much time backward in seconds will be checked in the logs.
*   **`cache -> allOf`**: All comparisons within this field must be met for the rule to generate an alert.
*   **`cache -> oneOf`**: Any comparison within this field must be met for the rule to generate an alert.

### Common Iteration Parameters

Both `cache` and `search` iterations share common parameters:

*   **`[cache | search] -> minCount`**: Defines the minimum number of logs that must be obtained as a result for the rule to be met.
*   **`[cache | search] -> save`**: Specifies required fields to save, either for use in the next cycle iteration or to complete the information of the alerts.
    *   **`[cache | search] -> save -> field`**: The original name of the field to store.
    *   **`[cache | search] -> save -> alias`**: The alias or name to access the field. There cannot be two or more aliases with the same name within the same iteration.

---

## Field Referencing and Querying

Fields are referenced as a series of keys separated by dots. Special wildcard characters and operators can be used for flexible querying.

### Field Syntax

The syntax for a field (`cache -> [allOf | oneOf] -> field` and `[cache | search] -> save -> field`) supports:

*   **Dot Notation**: Keys separated by dots (e.g., `name.last`).
*   **Wildcard Characters**:
    *   `*`: Matches any sequence of characters (e.g., `child*.2`).
    *   `?`: Matches any single character (e.g., `c?ildren.0`).
*   **Slice Access**: Use the index as the key to access a slice value (e.g., `children.1`).
*   **Slice Length/Child Path**: Use the `#` character to get the number of elements in a slice (e.g., `children.#`) or to access a child path.
*   **Escaping**: Dot and wildcard characters can be escaped with `\`.
*   **Slice Querying**:
    *   Query a slice for the first match using `#(...)`.
    *   Find all matches with `#(...)#`.
    *   These queries can use comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`) and simple pattern matching operators (`%` and `!%`).

**Example JSON Structure:**

```json
{
  "name": {"first": "Tom", "last": "Anderson"},
  "age":37,
  "children": ["Sara","Alex","Jack"],
  "fav.movie": "Deer Hunter",
  "friends": [
    {"first": "Dale", "last": "Murphy", "age": 44, "nets": ["ig", "fb", "tw"]},
    {"first": "Roger", "last": "Craig", "age": 68, "nets": ["fb", "tw"]},
    {"first": "Jane", "last": "Murphy", "age": 47, "nets": ["ig", "tw"]}
  ]
}
```

**Field Access Examples:**

*   `"name.last"` >> `"Anderson"`
*   `"age"` >> `37`
*   `"children"` >> `["Sara","Alex","Jack"]`
*   `"children.#"` >> `3`
*   `"children.1"` >> `"Alex"`
*   `"child*.2"` >> `"Jack"`
*   `"c?ildren.0"` >> `"Sara"`
*   `"fav\.movie"` >> `"Deer Hunter"`
*   `"friends.#.first"` >> `["Dale","Roger","Jane"]`
*   `"friends.1.last"` >> `"Craig"`
*   `"friends.#(last=="Murphy").first"` >> `"Dale"`
*   `"friends.#(last=="Murphy")#.first"` >> `["Dale","Jane"]`
*   `"friends.#(age>45)#.last"` >> `["Craig","Murphy"]`
*   `"friends.#(first%"D*").last"` >> `"Murphy"`
*   `"friends.#(first!%"D*").last"` >> `"Craig"`
*   `"friends.#(nets.#(==\"fb\"))#.first"` >> `["Dale","Roger"]`

---

## Operators

Operators are used in comparisons within correlation rules (`cache -> [allOf | oneOf] -> operator`). The `value` to compare against can be a literal or an alias content from a previous iteration.

*   **`==` (Exact Equality - Case Sensitive)**
    *   True if the field's content is exactly equal to the "value" content.
    *   `hello == Hello` //False
    *   `hello == hello` //True

*   **`::` (Equality - Case Insensitive)**
    *   True if the field's content is equal to the "value" content, ignoring case.
    *   `hello :: Hello` //True
    *   `hello :: hello` //True

*   **`!=` or `<>` (Inequality - Case Sensitive)**
    *   True if the field's content is unequal to the "value" content.
    *   `hello != Hello` //True
    *   `hello != hello` //False

*   **`!!` (Inequality - Case Insensitive)**
    *   True if the field's content is unequal to the "value" content, ignoring case.
    *   `hello !! Hello` //False
    *   `hello !! hello` //False

*   **`contains` (Substring Check)**
    *   True if the "value" content is part of the field content.
    *   `“hello world” contains “world”` //True
    *   `“hello world” contains “worlds”` //False

*   **`not contain` (Not Substring Check)**
    *   True if the "value" content is not part of the field content.
    *   `” hello world ” not contain ” world ”` //False
    *   `” hello world ” not contain ” worlds”` //True

*   **`in`**
    *   True if the field content is part of the "value" content.

*   **Classic Mathematical Operators**: `==`, `!=`, `<`, `<=`, `>`, `>=`
    *   These operators apply only to numbers and are used when both the field content and the "value" are numeric. They can also be used when querying slices.

---

## Summary

UTMStack's alert management and data population capabilities are integral to its threat detection system. By leveraging a structured approach to alert detail population through predefined aliases, automatic geolocation, and flexible data iteration methods (Elasticsearch/OpenSearch and correlation engine cache), the platform ensures comprehensive and accurate alert generation. The powerful field referencing syntax, complete with wildcards and slice querying, combined with a diverse set of comparison operators, enables analysts to define highly specific and effective correlation rules for identifying potential security incidents.