# String Filtering and Pattern Matching

This guide provides a comprehensive overview of string filtering conditions and pattern matching capabilities within UTMStack, including containment checks, field existence, and regular expressions, which are essential for effective log analysis and threat detection. These filtering functionalities are integral to modules like Log Explorer and correlation rules.

## Overview of Filtering Capabilities

UTMStack provides comprehensive data parsing based on user search requirements, enabling the definition of filters to track logs from specific sources or isolate events. The Log Explorer module, for instance, offers extensive filtering functionality, allowing users to narrow down searches to specific index patterns or define custom search parameters. This ensures a targeted and efficient search experience.

## String Filtering Conditions

Various operators are available for filtering string-based field content:

### `contain`
This operator is true if the "value" content is a substring of the field content.
- Example: `"hello world" contain "world"` //True
- Example: `"hello world" contain "worlds"` //False

### `not contain`
This operator is true if the "value" content is not a substring of the field content.
- Example: `"hello world" not contain "world"` //False
- Example: `"hello world" not contain "worlds"` //True

### `in`
This operator is true if the field content is part of the "value" content.
- Example: `"world" in "hello, world, this, is, a, test"` //True
- Example: `"worlds" in "hello, world, this, is, a, test"` //False

### `not in`
This operator is true if the field content is not part of the "value" content.
- Example: `"world" not in "hello, world, this, is, a, test"` //False
- Example: `"worlds" not in "hello, world, this, is, a, test"` //True

### `start with`
This operator is true if the "value" content is a prefix of the field content.
- Example: `"hello world" start with "world"` //False
- Example: `"hello world" start with "hello"` //True

### `not start with`
This operator is true if the "value" content is not a prefix of the field content.
- Example: `"hello world" not start with "world"` //True
- Example: `"hello world" not start with "hello"` //False

### `end with`
This operator is true if the "value" content is a suffix of the field content.
- Example: `"hello world" end with "world"` //True
- Example: `"hello world" end with "hello"` //False

### `not end with`
This operator is true if the "value" content is not a suffix of the field content.
- Example: `"hello world" not end with "world"` //False
- Example: `"hello world" not end with "hello"` //True

## Pattern Matching with Regular Expressions

Regular expressions provide powerful pattern matching capabilities for field content.

### `regexp`
This operator is true if the field content matches the regular expression specified in "value".
- Example: `"adam[23]" regexp "^[a-z]+\\[[0-9]+\\]$"` //True
- Example: `"hello world" regexp "^[a-z]+\\[[0-9]+\\]$"` //False

### `not regexp`
This operator is true if the field content does not match the regular expression specified in "value".
- Example: `"adam[23]" not regexp "^[a-z]+\\[[0-9]+\\]$"` //False
- Example: `"hello world" not regexp "^[a-z]+\\[[0-9]+\\]$"` //True

## Field Existence Checks

These operators determine if a field exists, regardless of its content. For these, the "value" must be left empty.

### `exist`
This operator is true if the field exists.

### `not exist`
This operator is true if the field does not exist.

## Field Referencing and Wildcards

When defining filtering conditions, fields are referenced as a series of keys separated by dots. Special wildcard characters and slice access methods are available:

*   **Wildcard Characters**: `*` and `?` can be used within field names.
*   **Slice Value Access**: Use the index as the key to access a slice value (e.g., `children.1`).
*   **Slice Length/Child Path**: Use the `#` character to get the number of elements in a slice or to access a child path (e.g., `children.#`).
*   **Escaping**: Dot (`.`) and wildcard characters can be escaped with `\`.
*   **Querying Slices**:
    *   `# (...)`: Query a slice for the first match.
    *   `# (...) #`: Find all matches in a slice.
*   **Simple Pattern Matching Operators**: `%` and `!%` can also be used.

### Field Referencing Examples

Consider the following JSON structure:
```json
{
  "name": {"first": "Tom", "last": "Anderson"},
  "age":37,
  "children": ["Sara","Alex","Jack"],
  "fav.movie": "Deer Hunter",
  "friends": [
    {"first": "Dale", "last": "Murphy", "age": 44, "nets": ["ig", "fb", "tw"]},
    {"first": "Roger", "last": "Craig", "age": 68, "nets": ["fb", "tw"]},
    {"first": "Jane", "last": "Murphy", "age": 47, "nets": ["ig", "tw"]}
  ]
}
```

Examples of field references:
*   `"name.last"` >> `"Anderson"`
*   `"age"` >> `37`
*   `"children"` >> `["Sara","Alex","Jack"]`
*   `"children.#"` >> `3`
*   `"children.1"` >> `"Alex"`
*   `"child*.2"` >> `"Jack"`
*   `"c?ildren.0"` >> `"Sara"`
*   `"fav\.movie"` >> `"Deer Hunter"`

## Summary

UTMStack's robust filtering and pattern matching capabilities empower users to precisely analyze log data. By leveraging string filtering conditions like containment and prefix/suffix checks, field existence operators, and advanced regular expressions, users can define highly specific criteria for threat detection, incident response, and general data analysis. The flexible field referencing, including wildcards and slice access, further enhances the power and precision of these filtering mechanisms.