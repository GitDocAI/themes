# Alert Configuration

This guide provides comprehensive instructions for setting up alert rules within UTMStack, leveraging cache-based iteration, field comparisons, and query syntax to detect and respond to security incidents. Correlation rules are defined frameworks that aid analysts in detecting network threats through automated log analysis, swiftly identifying potential security incidents and generating alerts. UTMStack's real-time correlation engine processes over 128,000 rules pre-ingestion, forming a critical defense mechanism for network security and compliance.

## Correlation Rules Overview

Correlation rules in UTMStack are designed to detect network threats by automatically analyzing logs. Each rule is defined by specific fields, such as its name and severity, and generates alerts to notify users of varying threat levels. This robust system is essential for maintaining network security and compliance.

## Rule Definition Fields

The following fields are used to define a correlation rule:

*   **name**: The name used for the alerts generated by the current rule.
*   **severity**: The severity level of the alerts for this rule. Possible values include `Low`, `Medium`, `High`, with the initial letter capitalized.
*   **description**: A description that will appear in the generated alerts.
*   **solution**: Specifies a known solution for the incident detected by the rule, if available.
*   **category**: A category in which the alert can be grouped.
*   **tactic**: Identifies if an incident detected by this rule fits into any attack tactics.
*   **dataTypes**: An array of string values representing the data types applied to a rule. Only logs with a `dataType` field matching at least one of these values will be processed by this rule.
*   **reference**: A list of URLs providing more information about the detected attack.
*   **frequency**: How often, in seconds, the alert condition should be checked.

## Iteration Methods: Cache vs. Search

Alert rules can be configured to perform iterations on either the correlation engine's cache or directly on Elasticsearch/OpenSearch. You must use either `cache` or `search`, but not both, for a given rule.

### Cache-Based Iteration (`cache`)

The `cache` field declares that iterations will occur on the cache of the correlation engine. This method is recommended for rules that analyze logs within a maximum timeframe of 1 hour.

#### Cache Iteration Structure

*   **cache -> allOf**: All comparisons defined within this field must be met for the rule to generate an alert.
*   **cache -> oneOf**: Any comparison defined within this field must be met for the rule to generate an alert.

#### Comparison Parameters

Within `allOf` or `oneOf`, the following parameters define the comparison:

*   **cache -> [allOf | oneOf] -> field**: The field on which the comparison will be applied. This field can contain special wildcard characters (`*` and `?`). To access a slice value, use the index as the key. To get the number of elements in a slice or to access a child path, use the `#` character. Dot and wildcard characters can be escaped with `\`. You can also query a slice for the first match using `#(...)` or find all matches with `#(...)#`. Comparison operators (`==, !=, <, <=, >, >=`) and simple pattern matching operators (`%` and `!%`) can be used in queries.
*   **cache -> [allOf | oneOf] -> operator**: The operator to use in the comparison.
*   **cache -> [allOf | oneOf] -> value**: The value to compare against the content of `cache -> [allOf | oneOf] -> field`. In subsequent iterations, an alias can be used to reference content from a previous iteration.

#### Time and Count Parameters

*   **cache -> timeLapse**: Specifies how much time backward, in seconds, will be checked in the logs.
*   **[cache | search] -> minCount**: Defines the minimum number of logs that must be obtained as a result for the rule to be met.

### Search-Based Iteration (`search`)

The `search` field declares that iterations will occur on Elasticsearch/OpenSearch. This method is recommended when the analysis period exceeds 1 hour or when the rule's complexity is very high and cannot be achieved using the cache.

#### Search Iteration Structure

*   **search -> query**: The Elasticsearch or OpenSearch query in JSON format. The query must be enclosed in simple quotation marks.

#### Time and Count Parameters

*   **[cache | search] -> minCount**: Defines the minimum number of logs that must be obtained as a result for the rule to be met.

### When to Use Cache or Search

*   **Cache**: Recommended for rules analyzing logs within a maximum of 1 hour.
*   **Search**: Recommended when the analysis period exceeds 1 hour or for rules with very high complexity that cannot be achieved using the cache.

## Saving Fields and Aliases

The `save` field is used to store required fields for use in subsequent iterations or to complete alert information.

*   **[cache | search] -> save -> field**: The original name of the field to store.
*   **[cache | search] -> save -> alias**: The alias or name to access the stored field. There cannot be two or more aliases with the same name within the same iteration.

In the last iteration, the system uses specific aliases to populate alert details:

*   Protocol
*   SourceUser
*   SourceHost
*   SourceIP
*   SourcePort
*   DestinationUser
*   DestinationHost
*   DestinationIP
*   DestinationPort

Geolocation information will be automatically filled from the `SourceIP` and `DestinationIP` aliases. If `SourceIP` or `DestinationIP` aliases do not exist, the system will generate them using `SourceHost` and `DestinationHost`, and vice versa.

If any field is saved with the aliases `AlertName` and `AlertCategory` in the last iteration, the alert name or category will be overwritten with the content of those aliases.

## Field Querying Syntax

Fields are accessed as a series of keys separated by dots. Wildcard characters (`*` and `?`) can be used, and `.` or `*` can be escaped with `\`.

Examples of field querying based on a JSON structure:

```json
{
  "name": {"first": "Tom", "last": "Anderson"},
  "age":37,
  "children": ["Sara","Alex","Jack"],
  "fav.movie": "Deer Hunter",
  "friends": [
    {"first": "Dale", "last": "Murphy", "age": 44, "nets": ["ig", "fb", "tw"]},
    {"first": "Roger", "last": "Craig", "age": 68, "nets": ["fb", "tw"]},
    {"first": "Jane", "last": "Murphy", "age": 47, "nets": ["ig", "tw"]}
  ]
}
```

Query examples:

*   `"name.last"` >> `"Anderson"`
*   `"age"` >> `37`
*   `"children"` >> `["Sara","Alex","Jack"]`
*   `"children.#"` >> `3` (number of elements in slice)
*   `"children.1"` >> `"Alex"` (access slice by index)
*   `"child*.2"` >> `"Jack"` (wildcard in key)
*   `"c?ildren.0"` >> `"Sara"` (wildcard in key)
*   `"fav\.movie"` >> `"Deer Hunter"` (escaped dot)
*   `"friends.#.first"` >> `["Dale","Roger","Jane"]` (all first names of friends)
*   `"friends.1.last"` >> `"Craig"` (last name of second friend)
*   `"friends.#(last=="Murphy").first"` >> `"Dale"` (first match in slice based on condition)
*   `"friends.#(last=="Murphy")#.first"` >> `["Dale","Jane"]` (all matches in slice based on condition)
*   `"friends.#(age>45)#.last"` >> `["Craig","Murphy"]` (all matches based on numeric condition)
*   `"friends.#(first%"D*").last"` >> `"Murphy"` (first match based on pattern)
*   `"friends.#(first!%"D*").last"` >> `"Craig"` (first match based on negative pattern)
*   `"friends.#(nets.#(=="fb"))#.first"` >> `["Dale","Roger"]` (matches based on nested array condition)

## Operators

Operators are used to compare the field's content with a specified value.

### Equality and Inequality Operators

*   **`==`**: True if the field's content is exactly equal to the "value" content (case-sensitive).
    *   `hello == Hello` //False
    *   `hello == hello` //True
*   **`::`**: True if the field's content is equal to the "value" content (case-insensitive).
    *   `hello :: Hello` //True
    *   `hello :: hello` //True
*   **`!=` y `<>`**: True if the field's content is unequal to the "value" content (case-sensitive).
    *   `hello != Hello` //True
    *   `hello != hello` //False
*   **`!!`**: True if the field's content is unequal to the "value" content (case-insensitive).
    *   `hello !! Hello` //False
    *   `hello !! hello` //False

### String Containment Operators

*   **`contains`**: True if the "value" content is part of the field content.
    *   `“hello world” contains “world”` //True
    *   `“hello world” contains “worlds”` //False
*   **`not contain`**: True if the "value" content is not part of the field content.
    *   `” hello world ” not contain ” world ”` //False
    *   `” hello world ” not contain ” worlds”` //True
*   **`in`**: True if the field content is part of the "value" content.

### Regular Expression Operators

*   **`regexp`**: True if the field's content matches the regular expression in "value".
    *   `” hello world ” regexp ”^[a-z]+\[[0-9]+\]$”` //False
    *   `” hello world [123] ” regexp ”^[a-z]+\[[0-9]+\]$”` //True
*   **`not regexp`**: True if the field's content does not match the regular expression in "value".
    *   `” hello world [123] ” not regexp ”^[a-z]+\[[0-9]+\]$”` //False
    *   `” hello world ” not regexp ”^[a-z]+\[[0-9]+\]$”` //True

### Existence and CIDR Operators

*   **`exist`**: True if the field exists. The "value" must be left empty.
*   **`not exist`**: True if the field does not exist. The "value" must be left empty.
*   **`in cidr`**: True if the IP in the field is within the value range.
*   **`not in cidr`**: True if the IP in the field is not within the value range.

### Classic Mathematical Operators (Numeric Only)

These operators apply only to numbers. Use them when both the field content and the "value" are numeric.

*   `<` (less than)
*   `>` (greater than)
*   `<=` (less than or equal to)
*   `>=` (greater than or equal to)

## Examples

### Windows Authentication Failure (Cache-Based)

This rule detects when a Windows user fails to authenticate with a server or workstation more than 5 times within a 60-second window, after an initial failed attempt within 15 seconds.

```yaml
- name: Windows authentication failure
  severity: Low
  description: A Windows user was unable to authenticate with the server or workstation more than 5 times.
  solution: Refer to NIST guidelines when creating password policies and set account lockout policies after a certain number of failed login attempts to prevent passwords from being guessed. Too strict a policy may create a denial of service condition and render environments un-usable, with all accounts used in the brute force being locked-out.
  category: User Account Authentication
  tactic: "Brute Force: Password Guessing"
  dataTypes: ["wineventlog"]
  reference:
    - "https://attack.mitre.org/techniques/T1110/001/"
  frequency: 10
  cache:
    - allOf:
        - field: logx.wineventlog.event_id
          operator: "=="
          value: 4625
      minCount: 1
      timeLapse: 15
      save:
        - field: logx.wineventlog.event_data.TargetUserName
          alias: DestinationUser
        - field: logx.wineventlog.host.name
          alias: DestinationHost
    - allOf:
        - field: logx.wineventlog.event_id
          operator: "=="
          value: 4625
        - field: logx.wineventlog.event_data.TargetUserName
          operator: "=="
          value: "{{.DestinationUser}}"
        - field: logx.wineventlog.host.name
          operator: "=="
          value: "{{.DestinationHost}}"
      minCount: 5
      timeLapse: 60
      save:
        - field: logx.wineventlog.event_data.TargetUserName
          alias: DestinationUser
        - field: logx.wineventlog.host.name
          alias: DestinationHost
        - field: logx.wineventlog.event_data.WorkstationName
          alias: SourceHost
        - field: logx.wineventlog.event_data.IpAddress
          alias: SourceIP
```

### Windows Authentication Failure (Search-Based)

This example achieves a similar goal using Elasticsearch queries, detecting multiple failed login attempts for the same user, excluding computer accounts.

```yaml
- name: Windows authentication failure
  severity: Low
  description: A Windows user was unable to authenticate with the server or workstation more than 5 times.
  solution: Refer to NIST guidelines when creating password policies and set account lockout policies after a certain number of failed login attempts to prevent passwords from being guessed. Too strict a policy may create a denial of service condition and render environments un-usable, with all accounts used in the brute force being locked-out.
  category: User Account Authentication
  tactic: "Brute Force: Password Guessing"
  dataTypes: ["wineventlog"]
  reference:
    - "https://attack.mitre.org/techniques/T1110/001/"
  frequency: 10
  search:
    - query: '{"size": 500, "query": {"bool": {"must": [{"match_phrase": {"logx.wineventlog.event_id": 4625}}], "filter": [{"range": {"@timestamp": {"gte": "now-15s", "lte": "now"}}}], "should": [], "must_not": []}}}'
      minCount: 1
      save:
        - field: logx.wineventlog.event_data.TargetUserName
          alias: DestinationUser
        - field: logx.wineventlog.host.name
          alias: DestinationHost
    - query: '{"size": 500, "query": {"bool": {"must": [{"match_phrase": {"logx.wineventlog.event_id": 4625}}, {"match_phrase": {"logx.wineventlog.event_data.TargetUserName": "{{.DestinationUser}}"}}], "filter": [{"range": {"@timestamp": {"gte": "now-60s", "lte": "now"}}}], "should": [], "must_not": [{"match_phrase": {"logx.wineventlog.event_data.TargetUserName": "{{.DestinationHost}}$"}}]}}}'
      minCount: 5
      save:
        - field: logx.wineventlog.event_data.TargetUserName
          alias: DestinationUser
        - field: logx.wineventlog.host.name
          alias: DestinationHost
        - field: logx.wineventlog.event_data.WorkstationName
          alias: SourceHost
        - field: logx.wineventlog.event_data.IpAddress
          alias: SourceIP
```

## Summary

UTMStack's alert configuration, driven by correlation rules, offers a powerful mechanism for automated threat detection. By defining rules with specific metadata, utilizing either cache-based or search-based iteration, and employing a rich set of operators and field querying syntax, users can create sophisticated alerts. The system further enhances alert detail by automatically populating critical information through predefined and custom aliases, including geolocation.