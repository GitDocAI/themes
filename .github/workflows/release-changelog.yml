name: Generate Release Changelog

on:
  release:
    types: [published]

jobs:
  generate-changelog:
    name: Generate AI Changelog
    runs-on: ubuntu-latest
    # Only run for production releases (not pre-releases)
    if: "!github.event.release.prerelease"

    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get previous tag
        id: get-tags
        run: |
          CURRENT_TAG="${{ github.event.release.tag_name }}"
          echo "Current release tag: $CURRENT_TAG"

          # Get all tags sorted by version (newest first)
          ALL_TAGS=$(git tag --sort=-v:refname)
          FOUND_CURRENT=false
          PREVIOUS_TAG=""

          for tag in $ALL_TAGS; do
            if [ "$FOUND_CURRENT" = true ]; then
              PREVIOUS_TAG="$tag"
              break
            fi
            if [ "$tag" = "$CURRENT_TAG" ]; then
              FOUND_CURRENT=true
            fi
          done

          if [ -z "$PREVIOUS_TAG" ]; then
            # No previous tag found, get first commit
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD | head -1)
            echo "No previous tag found, using first commit: $PREVIOUS_TAG"
          fi

          echo "Previous tag/commit: $PREVIOUS_TAG"
          echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Get commits between tags
        id: get-commits
        run: |
          CURRENT_TAG="${{ steps.get-tags.outputs.current_tag }}"
          PREVIOUS_TAG="${{ steps.get-tags.outputs.previous_tag }}"

          echo "Getting commits between $PREVIOUS_TAG and $CURRENT_TAG"

          # Get commit messages with hash, author, and message
          COMMITS=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %h %s (%an)" --no-merges)

          # Count commits
          COMMIT_COUNT=$(git rev-list --count ${PREVIOUS_TAG}..${CURRENT_TAG} --no-merges)

          echo "Found $COMMIT_COUNT commits"

          # Save commits to file (to handle multiline)
          echo "$COMMITS" > /tmp/commits.txt

          # Also get changed files summary
          CHANGED_FILES=$(git diff --stat ${PREVIOUS_TAG}..${CURRENT_TAG} | tail -1)
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT

      - name: Generate changelog with OpenAI
        id: generate-changelog
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          COMMITS=$(cat /tmp/commits.txt)
          CURRENT_TAG="${{ steps.get-tags.outputs.current_tag }}"
          PREVIOUS_TAG="${{ steps.get-tags.outputs.previous_tag }}"
          COMMIT_COUNT="${{ steps.get-commits.outputs.commit_count }}"
          CHANGED_FILES="${{ steps.get-commits.outputs.changed_files }}"

          # Create the prompt
          PROMPT="You are a product marketing writer creating release notes for end users of a SaaS product.

          Product: GitDocAI - AI-Powered Documentation as a Service
          Release: $CURRENT_TAG

          Here are the commit messages from this release:
          $COMMITS

          Create user-friendly release notes in markdown format. This is for NON-TECHNICAL end users who want to know what's new and improved in the product.

          IMPORTANT RULES:
          1. ONLY include changes that DIRECTLY AFFECT END USERS - things they can see, use, or benefit from
          2. COMPLETELY IGNORE internal/technical changes like:
             - CI/CD, GitHub Actions, deployment pipelines
             - Code refactoring, component restructuring
             - Database migrations, backend infrastructure
             - Internal API changes, gRPC, service communication
             - Developer tooling, linting, formatting
             - README updates, internal documentation
          3. Write in simple, non-technical language
          4. Focus on BENEFITS to the user, not implementation details
          5. Group into these categories ONLY (skip empty categories):
             - **What's New** - New features users can now use
             - **Improved** - Enhancements to existing features
             - **Fixed** - Bugs that were affecting users
          6. Start with a brief 1-2 sentence summary of the release highlights
          7. Use bullet points, be concise (one line per item)
          8. Do NOT wrap output in markdown code blocks
          9. Do NOT include commit hashes or author names
          10. If most commits are internal/technical, just summarize with 'Minor improvements and bug fixes'

          Write the release notes directly in markdown format, ready to be used as-is."

          # Call OpenAI API
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "$(jq -n \
              --arg prompt "$PROMPT" \
              '{
                model: "gpt-4o-mini",
                messages: [
                  {role: "system", content: "You are a technical writer specializing in software changelogs."},
                  {role: "user", content: $prompt}
                ],
                temperature: 0.3,
                max_tokens: 2000
              }')")

          # Extract the changelog from response
          CHANGELOG=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')

          if [ -z "$CHANGELOG" ]; then
            echo "Error: Failed to generate changelog"
            echo "Response: $RESPONSE"
            # Fallback to simple commit list
            CHANGELOG="## What's Changed

          $COMMITS

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG}"
          fi

          # Save changelog to file
          echo "$CHANGELOG" > /tmp/changelog.md

          # Add comparison link at the end
          echo "" >> /tmp/changelog.md
          echo "---" >> /tmp/changelog.md
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG}" >> /tmp/changelog.md

      - name: Update release body
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASE_ID="${{ github.event.release.id }}"
          CHANGELOG=$(cat /tmp/changelog.md)

          echo "Updating release $RELEASE_ID with generated changelog"

          # Update the release using GitHub CLI
          gh release edit "${{ github.event.release.tag_name }}" \
            --notes "$CHANGELOG" \
            --repo "${{ github.repository }}"

          echo "Release updated successfully!"

      - name: Output changelog
        run: |
          echo "## Generated Changelog"
          echo ""
          cat /tmp/changelog.md
